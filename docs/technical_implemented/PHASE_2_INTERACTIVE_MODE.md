# Phase 2: Interactive 모드 (대화 컨텍스트 유지)

> 📌 상위 문서: [COPILOT_INTEGRATION_DESIGN.md](./COPILOT_INTEGRATION_DESIGN.md)
> 📌 선행 작업: Phase 1 전체 완료

---

## 목표

Copilot CLI의 Interactive 모드를 지원하여 대화 컨텍스트를 유지하고, 후속 질문이 이전 대화를 참조할 수 있도록 한다.

---

## Phase 1 vs Phase 2 비교

| 항목 | Phase 1 (Programmatic) | Phase 2 (Interactive) |
|------|------------------------|----------------------|
| 실행 방식 | `copilot -p "prompt"` 매번 호출 | `copilot` 프로세스 유지 |
| 대화 컨텍스트 | ❌ 없음 | ✅ 유지 |
| 복잡도 | 낮음 | 높음 (PTY 필요) |
| 후속 질문 | 독립적 | 이전 대화 참조 가능 |
| 리소스 | 요청당 프로세스 생성 | 세션당 프로세스 유지 |

---

## 기술적 과제

### 1. PTY (Pseudo-Terminal) 필요

Interactive 모드는 터미널 환경을 기대함:
- 터미널 제어 시퀀스 처리
- stdin/stdout 양방향 통신
- 프롬프트 감지

**.NET에서의 옵션**:
| 옵션 | 설명 | 난이도 |
|------|------|--------|
| Pty.Net | .NET PTY 라이브러리 | 중간 |
| 외부 도구 | `script`, `expect` 등 | 높음 |
| Node.js 래퍼 | Node에서 PTY 처리 후 API | 중간 |

### 2. 응답 경계 감지

Interactive 모드에서는 응답이 언제 끝났는지 감지해야 함:
- 프롬프트 패턴 감지 (예: `> `)
- 타임아웃 기반 감지
- 특정 시퀀스 감지

### 3. 세션 관리

- 사용자별 프로세스 유지
- 비활성 세션 정리
- 세션 복구/재연결

---

## 아키텍처 (예상)

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Copilot.razor  │────▶│  CopilotHub     │────▶│ CopilotSession  │
│  (채팅 UI)      │◀────│  (SignalR)      │◀────│ Manager         │
└─────────────────┘     └─────────────────┘     └────────┬────────┘
                                                         │
                                                         ▼
                                                ┌─────────────────┐
                                                │  PTY Process    │
                                                │  (copilot)      │
                                                │  [세션 유지]     │
                                                └─────────────────┘
```

### 데이터 흐름

```
1. 세션 시작 요청
   │
   ▼
2. CopilotSessionManager: PTY로 `copilot` 프로세스 생성
   │
   ▼
3. 첫 질문 → stdin으로 전송
   │
   ▼
4. stdout 모니터링 → 응답 스트리밍
   │
   ▼
5. 응답 완료 감지 (프롬프트 패턴)
   │
   ▼
6. 후속 질문 → 같은 프로세스의 stdin으로 전송 (컨텍스트 유지)
   │
   ▼
7. 세션 종료 또는 타임아웃 → 프로세스 정리
```

---

## 컴포넌트 설계 (예상)

### 1. CopilotSessionManager (신규)

**책임**:
- PTY 프로세스 생명주기 관리
- 세션 ID ↔ 프로세스 매핑
- 비활성 세션 정리 (타임아웃)

### 2. CopilotSession (신규)

**책임**:
- 단일 Interactive 세션 관리
- stdin 쓰기, stdout 읽기
- 응답 경계 감지

### 3. CopilotService 확장

**추가 메서드**:
```
CreateSessionAsync() → sessionId
SendToSessionAsync(sessionId, prompt) → IAsyncEnumerable<string>
CloseSessionAsync(sessionId)
```

---

## 사용자 경험 변화

### Phase 1 (현재)

```
User: 이 파일 분석해줘
AI: [파일 분석 결과]

User: 좀 더 자세히 설명해줘
AI: [컨텍스트 없이 새로 시작 - "무엇을 자세히 설명할까요?"]
```

### Phase 2 (목표)

```
User: 이 파일 분석해줘
AI: [파일 분석 결과]

User: 좀 더 자세히 설명해줘
AI: [이전 분석 참조하여 상세 설명]  ← 컨텍스트 유지!
```

---

## 구현 옵션

### 옵션 A: Pty.Net 사용

```
장점: .NET 네이티브, 직접 제어
단점: 플랫폼별 이슈 가능

필요 패키지: Pty.Net
```

### 옵션 B: Node.js 중간 계층

```
장점: Node.js 생태계 활용 (node-pty 안정적)
단점: 추가 프로세스, 복잡도 증가

구조: Blazor → Node.js 서버 → PTY → copilot
```

### 옵션 C: WebSocket 기반 터미널

```
장점: 웹 터미널 라이브러리 활용 가능
단점: 과도한 구조

구조: xterm.js ↔ WebSocket ↔ PTY ↔ copilot
```

---

## 고려 사항

### 리소스 관리

| 항목 | Phase 1 | Phase 2 |
|------|---------|---------|
| 프로세스 수 | 요청당 1개 (임시) | 세션당 1개 (지속) |
| 메모리 | 낮음 | 높음 |
| 동시 사용자 | 많이 가능 | 제한적 |

### 세션 정리 정책

- 비활성 타임아웃: 10분
- 최대 세션 수: 사용자당 1개
- 서버 재시작 시: 모든 세션 종료

---

## 우선순위 및 일정

**Phase 2는 Phase 1 완료 후 필요에 따라 진행**

| 조건 | 결정 |
|------|------|
| Phase 1으로 충분 | Phase 2 보류 |
| 컨텍스트 유지 필요성 높음 | Phase 2 진행 |

### 예상 기간 (진행 시)

| 작업 | 기간 |
|------|------|
| PTY 연동 연구 및 POC | 3일 |
| CopilotSessionManager 구현 | 3일 |
| 응답 경계 감지 | 2일 |
| 통합 및 테스트 | 2일 |
| **합계** | **~10일** |

---

## 대안: 컨텍스트 시뮬레이션

Phase 2 없이 컨텍스트 유지 효과를 얻는 방법:

```
방법: 이전 대화 내용을 프롬프트에 포함

copilot -p "
이전 대화:
User: 이 파일 분석해줘
AI: [이전 응답 요약]

새 질문: 좀 더 자세히 설명해줘
"
```

**장점**: Phase 1 구조 유지
**단점**: 프롬프트 길이 제한, 토큰 비용 증가

---

## 결론

Phase 2는 **필요에 따라 진행**하며, Phase 1 완료 후 사용자 피드백을 기반으로 결정.

당장은 "컨텍스트 시뮬레이션" 방식으로 대응 가능.

---

*이 문서는 Phase 2 계획이며, 구체적인 구현 결정은 Phase 1 완료 후에 진행합니다.*
