# 비밀번호 인증 및 토큰 사용 설계

## 1. 개요
- MobileAICLI 접근을 보호하기 위해 단순 비밀번호 기반 인증과 토큰 기반 접근 제어를 추가하는 설계
- Copilot CLI/GitHub 연동에 필요한 토큰 관리 방식을 정의하여 비밀정보 노출을 방지
- 인증/인가 흐름을 Blazor Server 환경과 SignalR Hub 호출에 일관되게 적용

## 2. 현재 상태
- 앱 자체에 로그인/세션 개념이 없어 누구나 접근 가능
- Copilot CLI 인증은 `gh auth login`에 의존하며, 앱 설정에는 토큰 관련 필드가 없음
- SignalR Hub와 서비스 호출이 인증되지 않은 채 노출되어 있음

## 3. 목표
- 앱 진입 시 비밀번호 또는 액세스 토큰을 요구하고, 성공 시 세션/쿠키로 인증 상태 유지
- SignalR Hub 호출도 인증된 세션만 허용
- Copilot/GitHub 토큰은 환경변수나 보안 저장소에 두고, 설정/로그에 노출되지 않도록 관리

## 4. 접근 방법
### 4.1 인증 모드
- **비밀번호 모드**: 단일 앱 비밀번호를 환경변수(`MOBILEAICLI_PASSWORD_HASH`)로 주입, 로그인 폼에서 입력받아 해시 검증
- **토큰 모드**: 1) 앱 전용 Personal Access Token(PAT) 또는 2) 일회성 Access Token을 헤더/쿠키로 제출하는 방식 지원
- 구성 파일(`appsettings`)에는 비밀을 저장하지 않으며, 존재 시 경고 로그 후 무시

### 4.1.1 HTTPS 및 인증서 최소 비용 전략
- 개인 사용 시 공인 인증서 부담을 줄이기 위해 **자체 서명(Self-signed) 인증서**를 기본 옵션으로 허용
	- Windows: `dotnet dev-certs https --trust`로 사용자 프로필에 개발용 인증서 생성/신뢰 (로컬 전용)
	- Linux/macOS: `dotnet dev-certs https`로 PEM/PFX 생성 후 브라우저에 수동 신뢰 추가
- 배포 시에도 공인 인증서 대신 **사전 등록된 서명(thumbprint)만 허용**하는 전략 지원
	- `ALLOWED_CERT_THUMBPRINTS` 환경변수(쉼표 구분)로 허용 목록을 지정하고, 서버 시작 시 로드한 인증서의 지문이 목록에 없으면 거부
	- 이 방식을 사용하면 로컬에서 만든 자가서명 인증서를 안전하게 제한된 범위에서 사용 가능
- 리버스 프록시(Nginx/Caddy 등)를 이미 사용한다면, 프록시 계층에서 self-signed를 종단하고 앱은 프록시 뒤 HTTP로 통신하는 방식을 선택지로 문서화 (프록시→앱 통신 구간이 신뢰할 수 있는 로컬 네트워크일 때만)

### 4.2 인증 파이프라인
- ASP.NET Core 인증 미들웨어 추가: 쿠키 인증 스킴으로 로그인 성공 시 세션 유지
- 로그인 페이지/컴포넌트 추가: 비밀번호/토큰 입력, 실패 횟수 제한 및 지연(예: 실패 시 1초 대기)
- SignalR: `AddAuthorization` 후 Hub에 `[Authorize]` 적용, 토큰 모드일 경우 `access_token` 쿼리/헤더 처리를 허용
- 미인증 요청은 401 응답 또는 로그인 페이지로 리다이렉트

### 4.3 비밀 관리
- Copilot/GitHub 인증: 기본은 `gh auth login` 사용, 필요 시 `GH_TOKEN` 또는 `GITHUB_TOKEN` 환경변수 사용을 명시하고 설정 UI에서는 값 노출 금지
- 앱 비밀번호/토큰: 해시(SHA-256 이상)만 저장, 평문 비교 금지. 환경변수 미설정 시 앱이 시작을 거부하거나 “개발 모드 허용” 플래그로만 진행
- 로깅: 인증 관련 로그는 결과/원인만 기록하고 입력 값은 제거

### 4.4 권한 범위와 세션 관리
- 최소 권한: 파일 브라우저/터미널/Copilot 호출을 동일 권한으로 두되, 필요 시 역할 분리(조회 전용 vs 수정/실행) 확장 가능
- 세션 타임아웃: 유휴 시간 기반(예: 30분) 자동 로그아웃, 브라우저 탭 종료 시 쿠키 삭제 옵션 제공
- CSRF: 쿠키 인증 시 Antiforgery 토큰 활성화 유지, SignalR는 Bearer/쿼리 토큰 사용 시 필요 범위 최소화

### 4.5 UI/UX 고려
- 로그인 화면: 실패 사유 최소 노출(“인증 실패”), 남은 횟수 표시 생략
- 인증 상태 표시: 헤더에 로그인 사용자/토큰 모드 여부와 로그아웃 버튼 제공
- 토큰 입력 시 시크릿 필드 사용, 클립보드 복사/표시 토글 제공 없이 그대로 마스킹

## 5. 작업 단계
- [ ] 환경변수/설정 정의: 앱 비밀번호 해시, 토큰 사용 여부 플래그, 세션 타임아웃 값
- [ ] 인증 미들웨어/쿠키 스킴 구성, 로그인/로그아웃 엔드포인트 및 Blazor 컴포넌트 추가
- [ ] SignalR Hub에 `[Authorize]` 적용, 토큰 전달 방식 정리 및 매개변수 검증
- [ ] Copilot/GitHub 토큰 주입 규칙 문서화 및 설정 파서에서 비밀 필드 무시 처리
- [ ] 로깅/보안: 입력 마스킹, 실패 지연, 감사 로그(성공/실패 이벤트) 추가
- [ ] 테스트: 올바른 비밀번호, 잘못된 비밀번호, 토큰 누락, 세션 만료, 허브 호출 차단/허용 시나리오

## 6. 일정
- 인증 파이프라인 추가: 0.5일
- UI/로그인 화면 및 UX: 0.5일
- Hub/서비스 보호 및 테스트: 0.5일
- 보안 점검/문서화: 0.5일

## 7. 위험 요소
- 비밀 관리 오류로 평문 노출 위험 → 환경변수/보안 저장소만 사용, 로깅 차단
- 인증 미적용 엔드포인트 누락 → 모든 Hub/페이지에 `[Authorize]` 점검 체크리스트 적용
- 브루트포스 공격 → 실패 횟수 지연, 잠금 임계치 설정으로 완화

## 8. 기술 상세 (접기)
<details>
<summary>개발자용 세부 고려사항</summary>

- 해시 알고리즘은 PBKDF2/BCrypt/Scrypt 등 반복/솔트 포함 방식을 사용, 단순 SHA는 피하고 검증 라이브러리를 활용
- 토큰 모드: Bearer 헤더 또는 SignalR 쿼리 토큰 사용 시 HTTPS 전제, 평문 전송 금지
- 세션 스토리지: 쿠키 `HttpOnly`, `Secure`, `SameSite=Lax` 이상 설정, 프록시 환경에서는 `UseForwardedHeaders` 고려
- 운영/개발 모드 분리: 개발 모드에서만 인증 없이 접근 허용하는 스위치는 기본 `false`, PR 리뷰 시 경고 남김

</details>
